#!/usr/bin/env python3
"""
rfc2217-hotplug - Event handler for USB serial device hotplug events

Called by udev/systemd when devices are added or removed.
Determines slot_key from udev properties and calls portal API.

Usage:
    rfc2217-hotplug add <devnode> [id_path]
    rfc2217-hotplug remove <devnode> [id_path]
"""

import os
import sys
import time
import json
import hashlib
import subprocess
import urllib.request
import urllib.error

PORTAL_URL = "http://127.0.0.1:8080"
GEN_DIR = "/run/rfc2217/gen"
SETTLE_TIMEOUT = 5.0
SETTLE_INTERVAL = 0.1


def log(msg):
    """Log to stderr (goes to journal when run by systemd)."""
    print(f"[rfc2217-hotplug] {msg}", file=sys.stderr)


def get_slot_key(devnode, id_path_arg=None):
    """Get slot_key from argument or udev query."""
    # If passed as argument, use it
    if id_path_arg:
        return id_path_arg

    # Query udev for ID_PATH
    try:
        result = subprocess.run(
            ['udevadm', 'info', '-q', 'property', '--property=ID_PATH', devnode],
            capture_output=True, text=True, check=True
        )
        for line in result.stdout.splitlines():
            if line.startswith('ID_PATH='):
                return line.split('=', 1)[1]
    except subprocess.CalledProcessError:
        pass

    return None


def slot_key_hash(slot_key):
    """Hash slot_key for filename."""
    return hashlib.sha256(slot_key.encode()).hexdigest()[:16]


def get_next_gen(slot_key):
    """Increment and return generation number for slot."""
    os.makedirs(GEN_DIR, exist_ok=True)
    path = os.path.join(GEN_DIR, f"{slot_key_hash(slot_key)}.gen")

    gen = 0
    try:
        with open(path, 'r') as f:
            gen = int(f.read().strip())
    except (FileNotFoundError, ValueError):
        pass

    gen += 1

    with open(path, 'w') as f:
        f.write(str(gen))

    return gen


def wait_for_device(devnode, timeout=SETTLE_TIMEOUT):
    """Wait for device to be usable."""
    deadline = time.time() + timeout
    while time.time() < deadline:
        if os.path.exists(devnode):
            try:
                fd = os.open(devnode, os.O_RDWR | os.O_NONBLOCK)
                os.close(fd)
                return True
            except OSError:
                pass
        time.sleep(SETTLE_INTERVAL)
    return False


def call_portal_api(endpoint, data):
    """Call portal API endpoint."""
    url = f"{PORTAL_URL}{endpoint}"
    body = json.dumps(data).encode('utf-8')
    req = urllib.request.Request(
        url,
        data=body,
        headers={'Content-Type': 'application/json'},
        method='POST'
    )

    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            result = json.loads(resp.read().decode('utf-8'))
            return True, result
    except urllib.error.HTTPError as e:
        try:
            error_body = e.read().decode('utf-8')
            return False, json.loads(error_body)
        except:
            return False, {'error': str(e)}
    except urllib.error.URLError as e:
        return False, {'error': str(e)}
    except Exception as e:
        return False, {'error': str(e)}


def handle_add(devnode, id_path_arg):
    """Handle device add event."""
    slot_key = get_slot_key(devnode, id_path_arg)
    if not slot_key:
        log(f"ERROR: Cannot determine slot_key for {devnode}")
        return 1

    log(f"ADD: devnode={devnode} slot_key={slot_key}")

    # Wait for device to settle
    if not wait_for_device(devnode):
        log(f"WARNING: Device {devnode} not ready after {SETTLE_TIMEOUT}s")
        # Continue anyway - portal will handle the error

    gen = get_next_gen(slot_key)
    log(f"Generation: {gen}")

    success, result = call_portal_api('/api/start', {
        'slot_key': slot_key,
        'devnode': devnode,
        'gen': gen
    })

    if success:
        log(f"Portal response: {result}")
        return 0
    else:
        log(f"Portal error: {result}")
        return 1


def handle_remove(devnode, id_path_arg):
    """Handle device remove event."""
    slot_key = get_slot_key(devnode, id_path_arg)
    if not slot_key:
        # On remove, device is gone, so we might not be able to query udev
        # If no id_path was passed, we can't identify the slot
        log(f"ERROR: Cannot determine slot_key for {devnode} (device already gone?)")
        return 1

    log(f"REMOVE: devnode={devnode} slot_key={slot_key}")

    gen = get_next_gen(slot_key)
    log(f"Generation: {gen}")

    success, result = call_portal_api('/api/stop', {
        'slot_key': slot_key,
        'gen': gen
    })

    if success:
        log(f"Portal response: {result}")
        return 0
    else:
        log(f"Portal error: {result}")
        return 1


def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <add|remove> <devnode> [id_path]")
        sys.exit(1)

    action = sys.argv[1]
    devnode = sys.argv[2]
    id_path_arg = sys.argv[3] if len(sys.argv) > 3 else None

    if action == 'add':
        sys.exit(handle_add(devnode, id_path_arg))
    elif action == 'remove':
        sys.exit(handle_remove(devnode, id_path_arg))
    else:
        print(f"Unknown action: {action}")
        sys.exit(1)


if __name__ == '__main__':
    main()
